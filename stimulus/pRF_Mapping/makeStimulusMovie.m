function s = makeStimulusMovie( display, stim, res )
% function s = makeStimulusMovie( display, stim, res )
%
% This function generates a series of movie frames used for stimulus
% presenation as well as pRF estimation
%
% The function depends upon the bar centers and angles generated by
% getBarSequence.m
%
% INPUT
%   display
%       .resolution     - resolution of screen in pixels (replaced if res is an input)
%   	.screenAngle    - resolution of screen in degrees (constant)
%   stim
%   .StimulusType           = DriftingBar or MultiFocal
%       .secPerTR   - TR duration in seconds
%       .durSec     - stimulus duration in seconds
%       .numTRs     - stim.durSec / stim.secPerTr
%       .centersDeg(1:numTRs,1:2) - centers in deg, (0,0) is screen center (-y is up)
%   	.motDirsRad(1:numTRs,1) - direction of motion in radians (0 to the right, pi/2 is up)
%       [.radDeg]     - radius of stimulus aperture in degrees (default is  full screen)
%   	[.fixMaskRadDeg]- radius of fixation MASK in degrees
%         .wedgeStartDeg(1:nStimRegions) = start of wedges (in degree, from vertical)
%         .wedgeSizeDeg(1:nStimRegions) = wedges width (in degree, will draw in CW direction)
%         .ringOutDeg(1:nStimRegions) = outer radii of the arcs
%         .ringSizeDeg(1:nStimRegions) = width of the arcs (outer - inner radii)
%       .scotoma
%           .flag   - [bool] toggle scotoma on/off
%           .center - [x y] center in degrees
%           .rad    - radius in degrees


%   [res]           - downsampled resolution
% OUTPUT
%   s               - structure containing movie params
%       .frames     - image frames
%       .nx         - num pix along the x-dim
%       .ny         - num pix along the y-din
%       .x          - meshgrid of x-vals in degrees
%       .y          - meshgrid of y-vals in degrees
%       .dx         - delta pix along the x-dim
%       .dy         - delta pix along the y-dim

% VERSION HISTORY
%   1.0 (02.22.2012, ZRE)
%       - created to facilitate the generation of the stimulus movie
%       - allowed for variable output resolution
%       - returns a structure that may need to be modified for
%       compatability with pRF_estimate
%   1.1 (02.24.2012, ZRE)
%       - removed +pi/2 to the angle input into makeBarImage call. Rotating
%       the bar so that it is pependicular to the motion direction is now
%       taken care of within makeBarImage
%       - change stim.angsRad -> stim.motDirsRad
%   02.24.2012, PB
%         - changed the definition of s.x and s.y to allow for rectangular
%         matrices (nx ~= ny) in case stim.radDeg is not provided
%         - 'MASK' definition: changed ones -> zeros
%   03/22/2012 PB
%         - changed definition of x and y -> see XYdefinition_explain.m
%         - added option for MultiFocal stimuli
%   03/07/2013 PB
%         - added option for RandomBar stimuli

% default to drifitng bar if stimulus type is not specified
if ~isfield( stim, 'StimulusType' )
    stim.StimulusType = 'DriftingBar' ;
end

% deal with non-default resolution requests
if exist( 'res', 'var' )
    if numel( res ) == 1
        res = res * [1 1];
    end
    % downsample
    display.resolution = res;
else
    % set res to screen resolution
    res = display.resolution;
end

% generate aperture and fixation MASK
if isfield( stim, 'radDeg' )
    MASK = makeMaskImage( display, stim );
else
    % full screen (no MASK)
    MASK = zeros( res(2), res(1) );
end

% generate scotoma MASK
if stim.scotoma.flag
    scotomaImg = makeScotomaImage( display, stim );
    MASK = ~MASK; % 0 = non stimulated (i.e. Masked)
    MASK = MASK .* scotomaImg;
    MASK = ~MASK; % switch back -> 1 = non stimulated (i.e. Masked)
end

% make basis x and y
[xpx ypx] = meshgrid(   ( 1 : display.resolution(1) ) - display.resolution(1)/2 ,...
    ( 1 : display.resolution(2) )  - display.resolution(2)/2 );
s.x = pix2angle( display, xpx );
s.y = pix2angle( display, ypx ) ;

s.nx = size( s.x,1 ) ;
s.ny = size( s.x,2 ) ;
s.dx = s.x(1,2) - s.x(1,1);
s.dy = s.y(2,1) - s.y(1,1);

if strcmp( stim.StimulusType , 'MultiFocal' )
    % for MultiFocal: define rad and ang (ang as in cartesian plane: starts from horizontal and proceedes
    % anti-clockwise)
    rad = sqrt(s.x.^2 + s.y.^2);
    [a,b] = meshgrid(linspace(-1,+1,s.nx),linspace(s.ny/s.nx,-s.ny/s.nx,s.ny)); 
    % +s.ny:-s.ny so that the stimulus is flipped up-down (negative = up) for compatibility with Zach's code

    ang = (atan2(b,a) / pi + 1)' * 180 ; % -pi:pi -> -1:1 -> 0:2  -> 0:360
    
    % create matrix holding one image per each arc in regDef file
    allRegions = repmat(rad*0,[1 1 size(stim.wedgeStartDeg,1)]);
    for i = 1:size(allRegions,3)
        % image is zero everywhere...
        img = rad*0;
        % except in the area occupied by the ith arc
        img( ang > stim.wedgeStartDeg(i) & ang <= ( stim.wedgeStartDeg(i) + stim.wedgeSizeDeg(i) )  & ...
            rad <= stim.ringOutDeg(i) &  rad > ( stim.ringOutDeg(i) - stim.ringSizeDeg(i) ) ) = 1;
        allRegions(:,:,i) = img;
    end
    
end

% make stimulus movie - (binary image)
s.frames = zeros( res(2), res(1), stim.numTRs );
for iTR = 1:stim.numTRs
    switch stim.StimulusType
        case 'ExpandingRing'
            thisframe = ~MASK .* abs( makeRingImage( display, stim, stim.centersDeg(iTR,:) ) );
            
        case {'DriftingBar', 'RandomBar'}
            thisframe = ~MASK .* abs( makeBarImage( display, stim, stim.motDirsRad(iTR), stim.centersDeg(iTR,:) ) );
            
        case 'MultiFocal'
            % sum the 'allRegions' matrix, only the pages holding the selected
            % regions
            activeRegions = find( stim.activeRegions(:,iTR) );
            thisframe = ~MASK .* ( sum( allRegions(:,:,activeRegions ),3 ) );
            
    end
    % flipUD so that negative means downward
%     s.frames(:,:,iTR) = flipud(thisframe) ;
    s.frames(:,:,iTR) = (thisframe) ;
end

return

%% -- Explain the way basis functions are created --
% XYdefinition_explain

cls

% set example display parameters (just so we can use pix2angle)
display.dist = 57;  %distance from screen (cm)
display.width = 38;   %width of screen (cm)
display.resolution = [1280 1024];
display.screenAngle = pix2angle( display, display.resolution );
display.center = floor(display.resolution/2);

% create x and y in deg 
n = display.screenAngle;
[xdeg ydeg] = meshgrid(   linspace( -n(1)/2, n(1)/2, display.resolution(1) ),...
                    linspace( -n(2)/2, n(2)/2, display.resolution(2) ) );
% this way, each pixel corresponds to a FIXED fraction of deg 

% define points in degrees and translate them into pixels (as you'd do to
% define the destRect of FillRect and other ptb functions)
distDeg = linspace( -n(1)/2, n(1)/2, display.resolution(1) );
distPix = angle2pix(display,distDeg) + display.center(1);

% plot them
figure(1); clf
plot(1:display.resolution(1),unique(xdeg),'.')
hold on
plot(distPix,distDeg,'.r')
legend( { 'linspace after px2angle' ; 'angle2px after linspace' } , 'location', 'best' )
axis square
title( 'old way' )

% the two don't correspond!
% our xdeg does not actually corresponds to values set by angle2pix (and
% this is bad, if we want to simultaneously  use textures defined by these
% matrices and other ptb functions, eg FrameRect

% so what we need to do is to create xdeg and ydeg in pixels first, then
% convert them into degrees (note: this only works if the center of gaze
% corresponds to screen center; but the same holds for the functions
% angle2pix and pix2angle)

n = display.screenAngle;
[xpx ypx] = meshgrid(   ( 1 : display.resolution(1) ) - display.center(1) ,...
                    ( 1 : display.resolution(2) )  - display.center(2) );
xdeg = pix2angle( display, xpx );
ydeg = pix2angle( display, ypx ) ;

figure(2); clf
plot(1:display.resolution(1),unique(xdeg),'.')
hold on
plot(distPix,distDeg,'.r')
axis square
title( 'new way' )






